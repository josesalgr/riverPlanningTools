#' @title Create the boundary file to the conservation management plannning software
#'
#' @description Return a data.frame
#' generated by information about the boudary data from river data.
#'
#' @param file Object of class [data.frame()] or [SpatialLinesDataFrame()] or [SpatialPolygonsDataFrame()] that specifies
#' the relation between planning (river PU's). This file must contain the following fields:
#' \describe{
#'    \item{`GridID`}{`integer` unique identifier for each planning unit.}
#'    \item{`NextDownID`}{`integer` unique identifier for the planning unit immediately below. Set -1
#'    there isn't one below.}
#'    \item{`Length`}{`numeric` value of distance between the `GridID` and `NextDownID`.}
#'    }
#' @param distance_limit distance limit to stop to building the relation between units.
#' @param connection_limit number of connections limit to stop to building the relation between units.
#' @param export_csv is TRUE to export a .csv file with boundary connections.
#' @return A [data.frame()].
#' @examples
#' \donttest{
#'  boundaryBuilder(file, distance_limit = 100, connection_limit = 20, export_csv = FALSE)
#' }
#'
#' @rdname boundaryBuilder
#' @export
#' @import methods utils

boundaryBuilder <- function(file, distance_limit = .Machine$integer.max,
                            connection_limit = .Machine$integer.max,
                            export_csv = FALSE, id = "GridID", nxt = "NextDownID", len = "Length"){
  
  #checking if the input is a shapefile
  if(methods::is(file, "SpatialLinesDataFrame") || is(file, "SpatialPolygonsDataFrame")){
    df = ggplot2::fortify(file@data)
    
    #checking if the variables exists
    var = c(id, nxt, len)
    if(!all(var %in% colnames(df))){
      var_needed <- which(!var %in% colnames(df))
      stop(paste("The following variables are needed: ", var[var_needed]), call. = FALSE)
    }
    
    df <- df[,var]
  }
  else if(is.data.frame(file)){
    
    #checking if the variables exists
    var = c(id, nxt, len)
    if(!all(var %in% colnames(df))){
      var_needed <- which(!var %in% colnames(df))
      stop(paste("The following variables are needed: ", var[var_needed]),call. = FALSE)
    }
      
    if(any(file[id][[1]] == file[nxt][[1]])){
      stop("There are ID's whith equal value of NextGridID.", call. = FALSE)
    }
    #rows_failed <- which(file[id][[1]] == file[nxt][[1]])
    #file[nxt][[1]][rows_failed] <- -1
    
    df = file
  }
  else{
    stop("Incompatible file (SpatialLinesDataFrame or DataFrame required)", call. = FALSE)
  }
  
  #creating empty data frame to distances
  data_distances <- timesTwo(df, connection_limit, distance_limit, id, nxt, len)
  
  if(export_csv == FALSE){
    return(data_distances)
  }
  else{
    utils::write.csv(data_distances, file="Longitudinal_distance.csv", row.names = FALSE)
  }
}


#How to use---------------------------------------------------------
#From .csv
#The .csv file must contain the following variables: GridID, NextDownID, Length

##Name_data_csv  = "Douro2.csv"
##file = read.csv(Name_data_csv)

#From shapefile data
#The shapefile must contain the following variables: GridID, HydroID, NextDownID, Length
##Name_data_shp = "River_500_Albers.shp"
##file = readOGR(Name_data_shp)

#Function
#distance = maximum distance allowed between units
#connection_limit = maximum connections allowed between units
##Create_longitudinal_distances(file)